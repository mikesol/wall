# Musings

Here are some random thoughts about Wall.

## Why I wrote Wall

The first languages I coded extensively in are Scheme and Python.  I loved Scheme for its flexibility and functional style and Python for its simple imperative syntax.  Since then, I've worked on projects in C, C++, C#, Java, JavaScript, TypeScript, Swift, Kotlin, Groovy, Objective-C, Haskell, Erlang, Clojure, Elixir, Ruby, F* and other languages.  Wall represents my best attempt to combine my favorite aspects of all those languages.  While it is impossible for me to make an exhaustive list of what these things are, here are some of them:

- Dependent types
- Automatic typing
- Strongly typed
- Easy type-checking in an IDE
- Colocation of tests and code
- Progaramtic manipulation of the AST
- Managed concurrency
- Pattern matching
- Lots of syntactic sugar
- Validation of input as a first-class citizen
- No runtime errors
- A robust library of pre-defined functions
- Duck typing
- Easy handling of monads
- Package management from git repos
- Compiles to fast binaries

## My hope

I would love to see Wall contribute to a discussion about IO in an increasingly interconnected world.  Most popular programming languages were created at a time where coders worked mostly with their own code.  In this day and age, as we rely more and more on other people's code and APIs, we need simple and powerful verification systems for JSON, YAML and the myriad of other formats and protocols that are being exchanged all the time.  It would be awesome if Wall made this easier.